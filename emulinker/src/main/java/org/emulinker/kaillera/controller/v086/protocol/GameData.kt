package org.emulinker.kaillera.controller.v086.protocol

import io.ktor.utils.io.core.ByteReadPacket
import io.ktor.utils.io.core.readAvailable
import io.netty.buffer.ByteBuf
import java.nio.ByteBuffer
import org.emulinker.kaillera.controller.messaging.MessageFormatException
import org.emulinker.kaillera.controller.v086.V086Utils
import org.emulinker.util.UnsignedUtil.getUnsignedShort
import org.emulinker.util.UnsignedUtil.putUnsignedShort
import org.emulinker.util.UnsignedUtil.readUnsignedShortLittleEndian

/**
 * A message sent by both the client and server, which contains game input data as a [ByteArray].
 *
 * After receiving a [GameData] message from all clients, the server concatenates the game data into
 * a single array which is returned back to all clients. If an exact copy of the array has already
 * been sent in the same direction (server to client or client to server), [CachedGameData] may be
 * sent instead.
 *
 * Message type ID: `0x12`.
 */
data class GameData
@Throws(MessageFormatException::class)
constructor(override val messageNumber: Int, val gameData: ByteArray) :
  V086Message(), ClientMessage, ServerMessage {
  override val messageTypeId = ID

  override val bodyBytes = V086Utils.Bytes.SINGLE_BYTE + V086Utils.Bytes.SHORT + gameData.size

  override fun writeBodyTo(buffer: ByteBuffer) {
    GameDataSerializer.write(buffer, this)
  }

  override fun writeBodyTo(buffer: ByteBuf) {
    GameDataSerializer.write(buffer, this)
  }

  // Method generated by Intellij.
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as GameData

    if (messageNumber != other.messageNumber) return false
    if (!gameData.contentEquals(other.gameData)) return false
    if (messageTypeId != other.messageTypeId) return false
    if (bodyBytes != other.bodyBytes) return false

    return true
  }

  // Method generated by Intellij.
  override fun hashCode(): Int {
    var result = messageNumber
    result = 31 * result + gameData.contentHashCode()
    result = 31 * result + messageTypeId
    result = 31 * result + bodyBytes
    return result
  }

  init {
    require(gameData.isNotEmpty()) { "gameData is empty" }
    require(gameData.size in 0..0xFFFF) { "gameData size out of range: ${gameData.size}" }
  }

  companion object {
    const val ID: Byte = 0x12

    // TODO(nue): Get rid of this.
    @Throws(Exception::class)
    fun main() {
      val data = ByteArray(9)
      val st = System.currentTimeMillis()
      val msg: GameData = create(0, data)
      val byteBuffer = ByteBuffer.allocateDirect(4096)
      for (i in 0..0xfffe) {
        msg.writeTo(byteBuffer)
        byteBuffer.clear()
      }
      println("et=" + (System.currentTimeMillis() - st))
    }

    /** Same as the constructor, but it makes a deep copy of the array. */
    @Throws(MessageFormatException::class)
    fun create(messageNumber: Int, gameData: ByteArray): GameData {
      return GameData(messageNumber, gameData.copyOf(gameData.size))
    }
  }

  object GameDataSerializer : MessageSerializer<GameData> {
    override val messageTypeId: Byte = ID

    override fun read(buffer: ByteBuf, messageNumber: Int): Result<GameData> {
      if (buffer.readableBytes() < 4) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.readByte() // This is always 0x00.
      val dataSize = buffer.getUnsignedShort()
      if (dataSize <= 0 || dataSize > buffer.readableBytes()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = ByteArray(dataSize)
      buffer.readBytes(gameData) // THIS IS PROBABLY SAFE
      return Result.success(create(messageNumber, gameData))
    }

    override fun read(buffer: ByteBuffer, messageNumber: Int): Result<GameData> {
      if (buffer.remaining() < 4) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.get() // This is always 0x00.
      val dataSize = buffer.getUnsignedShort()
      if (dataSize <= 0 || dataSize > buffer.remaining()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = ByteArray(dataSize)
      buffer.get(gameData)
      return Result.success(create(messageNumber, gameData))
    }

    override fun read(packet: ByteReadPacket, messageNumber: Int): Result<GameData> {
      if (packet.remaining < 4) {
        return parseFailure("Failed byte count validation!")
      }
      packet.readByte() // This is always 0x00.
      val dataSize = packet.readUnsignedShortLittleEndian()
      if (dataSize <= 0 || dataSize > packet.remaining) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = ByteArray(dataSize)
      packet.readAvailable(gameData) // TODO(nue): This might not work?
      return Result.success(create(messageNumber, gameData))
    }

    override fun write(buffer: ByteBuf, message: GameData) {
      buffer.writeByte(0x00)
      buffer.putUnsignedShort(message.gameData.size)
      buffer.writeBytes(message.gameData)
    }

    override fun write(buffer: ByteBuffer, message: GameData) {
      buffer.put(0x00.toByte())
      buffer.putUnsignedShort(message.gameData.size)
      buffer.put(message.gameData)
    }
  }
}
