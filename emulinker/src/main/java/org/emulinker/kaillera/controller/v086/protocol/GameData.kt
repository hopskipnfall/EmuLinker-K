package org.emulinker.kaillera.controller.v086.protocol

import io.netty.buffer.ByteBuf
import io.netty.buffer.ByteBufUtil
import io.netty.buffer.Unpooled
import io.netty.util.ReferenceCounted
import java.nio.ByteBuffer
import org.emulinker.kaillera.controller.messaging.MessageFormatException
import org.emulinker.kaillera.controller.v086.V086Utils
import org.emulinker.util.UnsignedUtil.putUnsignedShort

/**
 * A message sent by both the client and server, which contains game input data as a [ByteArray].
 *
 * After receiving a [GameData] message from all clients, the server concatenates the game data into
 * a single array which is returned back to all clients. If an exact copy of the array has already
 * been sent in the same direction (server to client or client to server), [CachedGameData] may be
 * sent instead.
 *
 * Message type ID: `0x12`.
 */
data class GameData
@Throws(MessageFormatException::class)
constructor(override var messageNumber: Int, val gameData: ByteBuf) :
  V086Message(), ClientMessage, ServerMessage, ReferenceCounted {
  override val messageTypeId = ID

  override val bodyBytes
    get() = V086Utils.Bytes.SINGLE_BYTE + V086Utils.Bytes.SHORT + gameData.readableBytes()

  override fun writeBodyTo(buffer: ByteBuffer) {
    GameDataSerializer.write(buffer, this)
  }

  override fun writeBodyTo(buffer: ByteBuf) {
    GameDataSerializer.write(buffer, this)
  }

  // Method generated by Intellij.
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as GameData

    if (messageNumber != other.messageNumber) return false
    if (!ByteBufUtil.equals(gameData, other.gameData)) return false
    if (messageTypeId != other.messageTypeId) return false
    if (bodyBytes != other.bodyBytes) return false

    return true
  }

  // Method generated by Intellij.
  override fun hashCode(): Int {
    var result = messageNumber
    result = 31 * result + ByteBufUtil.hashCode(gameData)
    result = 31 * result + messageTypeId
    result = 31 * result + bodyBytes
    return result
  }

  init {
    require(gameData.readableBytes() > 0) { "gameData is empty" }
    require(gameData.readableBytes() <= 0xFFFF) { "gameData size out of range: ${gameData.readableBytes()}" }
  }

  override fun refCnt(): Int = gameData.refCnt()

  override fun retain(): ReferenceCounted {
    gameData.retain()
    return this
  }

  override fun retain(increment: Int): ReferenceCounted {
    gameData.retain(increment)
    return this
  }

  override fun touch(): ReferenceCounted {
    gameData.touch()
    return this
  }

  override fun touch(hint: Any?): ReferenceCounted {
    gameData.touch(hint)
    return this
  }

  override fun release(): Boolean = gameData.release()

  override fun release(decrement: Int): Boolean = gameData.release(decrement)

  companion object {
    const val ID: Byte = 0x12

    /** Same as the constructor, but it makes a deep copy of the array. */
    @Throws(MessageFormatException::class)
    fun createAndMakeDeepCopy(messageNumber: Int, gameData: ByteBuf): GameData {
      return GameData(messageNumber, gameData.retainedDuplicate())
    }
  }

  object GameDataSerializer : MessageSerializer<GameData> {
    override val messageTypeId: Byte = ID

    override fun read(buffer: ByteBuf, messageNumber: Int): Result<GameData> {
      if (buffer.readableBytes() < 4) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.skipBytes(1) // This is always 0x00.
      val dataSize = buffer.readShortLE().toInt()
      if (dataSize <= 0 || dataSize > buffer.readableBytes()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }

      // Zero-copy slice. Retain it because GameData takes ownership.
      val gameData = buffer.readRetainedSlice(dataSize)
      return Result.success(GameData(messageNumber, gameData))
    }

    override fun write(buffer: ByteBuf, message: GameData) {
      buffer.writeByte(0x00)
      buffer.writeShortLE(message.gameData.readableBytes())
      buffer.writeBytes(message.gameData, message.gameData.readerIndex(), message.gameData.readableBytes())
    }

    fun write(buffer: ByteBuffer, message: GameData) {
      buffer.put(0x00.toByte())
      buffer.putUnsignedShort(message.gameData.readableBytes())
      val length = message.gameData.readableBytes()
      if (message.gameData.hasArray()) {
        buffer.put(message.gameData.array(), message.gameData.arrayOffset() + message.gameData.readerIndex(), length)
      } else {
        val bytes = ByteArray(length)
        message.gameData.getBytes(message.gameData.readerIndex(), bytes)
        buffer.put(bytes)
      }
    }
  }
}
