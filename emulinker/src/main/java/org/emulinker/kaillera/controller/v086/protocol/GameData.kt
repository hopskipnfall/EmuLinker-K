package org.emulinker.kaillera.controller.v086.protocol

import io.netty.buffer.ByteBuf
import io.netty.buffer.ByteBufUtil
import io.netty.util.ReferenceCounted
import java.nio.ByteBuffer
import org.emulinker.kaillera.controller.messaging.MessageFormatException
import org.emulinker.kaillera.controller.v086.V086Utils
import org.emulinker.util.UnsignedUtil.putUnsignedShort

/**
 * A message sent by both the client and server, which contains game input data as a [ByteBuf].
 *
 * After receiving a [GameData] message from all clients, the server concatenates the game data into
 * a single array which is returned back to all clients. If an exact copy of the array has already
 * been sent in the same direction (server to client or client to server), [CachedGameData] may be
 * sent instead.
 *
 * Message type ID: `0x12`.
 */
data class GameData(override var messageNumber: Int, val gameData: ByteBuf) :
  V086Message(), ClientMessage, ServerMessage, ReferenceCounted {

  override val messageTypeId = ID

  override val bodyBytes
    get() = V086Utils.Bytes.SINGLE_BYTE + V086Utils.Bytes.SHORT + gameData.readableBytes()

  override fun writeBodyTo(buffer: ByteBuffer) {
    GameDataSerializer.write(buffer, this)
  }

  override fun writeBodyTo(buffer: ByteBuf) {
    GameDataSerializer.write(buffer, this)
  }

  // Method generated by Intellij.
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as GameData

    if (messageNumber != other.messageNumber) return false
    if (messageTypeId != other.messageTypeId) return false
    // Use ByteBufUtil to compare ByteBuf content
    if (!ByteBufUtil.equals(gameData, other.gameData)) return false

    return true
  }

  // Method generated by Intellij.
  override fun hashCode(): Int {
    var result = messageNumber
    // Use ByteBufUtil to calculate hashCode for ByteBuf
    result = 31 * result + ByteBufUtil.hashCode(gameData)
    result = 31 * result + messageTypeId
    return result
  }

  init {
    require(gameData.readableBytes() > 0) { "gameData is empty" }
    require(gameData.readableBytes() <= 0xFFFF) {
      "gameData size out of range: ${gameData.readableBytes()}"
    }
  }

  companion object {
    const val ID: Byte = 0x12

    // TODO(nue): Get rid of this.
    @Throws(Exception::class)
    fun main() {
      // Benchmark code removed/disabled as it relied on VariableSizeByteArray
    }

    /** Same as the constructor, but it makes a deep copy of the array. */
    @Throws(MessageFormatException::class)
    fun createAndMakeDeepCopy(messageNumber: Int, gameData: ByteBuf): GameData {
      return GameData(messageNumber, gameData.retainedDuplicate())
    }
  }

  object GameDataSerializer : MessageSerializer<GameData> {
    override val messageTypeId: Byte = ID

    override fun read(buffer: ByteBuf, messageNumber: Int): Result<GameData> {
      if (buffer.readableBytes() < 3) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.skipBytes(1) // This is always 0x00.
      val dataSize = buffer.readShortLE().toInt()
      if (dataSize <= 0 || dataSize > buffer.readableBytes()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }

      // Read a retained slice to avoid copying.
      // The caller (GameData constructor) assumes ownership or at least we pass a retained buffer.
      // readRetainedSlice retains the returned buffer.
      val slice = buffer.readRetainedSlice(dataSize)
      return Result.success(GameData(messageNumber, slice))
    }

    override fun write(buffer: ByteBuf, message: GameData) {
      buffer.writeByte(0x00)
      buffer.writeShortLE(message.gameData.readableBytes())
      buffer.writeBytes(
        message.gameData,
        message.gameData.readerIndex(),
        message.gameData.readableBytes(),
      )
    }

    fun write(buffer: ByteBuffer, message: GameData) {
      buffer.put(0x00.toByte())
      buffer.putUnsignedShort(message.gameData.readableBytes())
      // Need t o read bytes from ByteBuf to ByteBuffer
      // This copies.
      val len = message.gameData.readableBytes()
      if (message.gameData.nioBufferCount() > 0) {
        buffer.put(message.gameData.nioBuffer())
      } else {
        val bytes = ByteArray(len)
        message.gameData.getBytes(message.gameData.readerIndex(), bytes)
        buffer.put(bytes)
      }
    }
  }

  override fun refCnt(): Int = gameData.refCnt()

  override fun retain(): ReferenceCounted {
    gameData.retain()
    return this
  }

  override fun retain(increment: Int): ReferenceCounted {
    gameData.retain(increment)
    return this
  }

  override fun touch(): ReferenceCounted {
    gameData.touch()
    return this
  }

  override fun touch(hint: Any?): ReferenceCounted {
    gameData.touch(hint)
    return this
  }

  override fun release(): Boolean = gameData.release()

  override fun release(decrement: Int): Boolean = gameData.release(decrement)
}
