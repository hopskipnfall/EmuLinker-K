package org.emulinker.kaillera.controller.v086.protocol

// import org.emulinker.util.get
import com.google.common.flogger.FluentLogger
import io.ktor.utils.io.core.readAvailable
import io.ktor.utils.io.core.remaining
import io.netty.buffer.ByteBuf
import java.nio.ByteBuffer
import kotlinx.io.Source
import org.emulinker.kaillera.controller.messaging.MessageFormatException
import org.emulinker.kaillera.controller.v086.V086Utils
import org.emulinker.util.UnsignedUtil.getUnsignedShort
import org.emulinker.util.UnsignedUtil.putUnsignedShort
import org.emulinker.util.UnsignedUtil.readUnsignedShortLittleEndian
import org.emulinker.util.VariableSizeByteArray
import org.emulinker.util.get
import org.emulinker.util.put

/**
 * A message sent by both the client and server, which contains game input data as a [ByteArray].
 *
 * After receiving a [GameData] message from all clients, the server concatenates the game data into
 * a single array which is returned back to all clients. If an exact copy of the array has already
 * been sent in the same direction (server to client or client to server), [CachedGameData] may be
 * sent instead.
 *
 * Message type ID: `0x12`.
 */
data class GameData
@Throws(MessageFormatException::class)
constructor(override var messageNumber: Int, var gameData: VariableSizeByteArray) :
  V086Message(), ClientMessage, ServerMessage {
  override val messageTypeId = ID

  override val bodyBytes = V086Utils.Bytes.SINGLE_BYTE + V086Utils.Bytes.SHORT + gameData.size

  override fun writeBodyTo(buffer: ByteBuffer) {
    GameDataSerializer.write(buffer, this)
  }

  override fun writeBodyTo(buffer: ByteBuf) {
    GameDataSerializer.write(buffer, this)
  }

  // Method generated by Intellij.
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as GameData

    if (messageNumber != other.messageNumber) return false
    if (gameData != other.gameData) return false
    if (messageTypeId != other.messageTypeId) return false
    if (bodyBytes != other.bodyBytes) return false

    return true
  }

  // Method generated by Intellij.
  override fun hashCode(): Int {
    var result = messageNumber
    result = 31 * result + gameData.hashCode()
    result = 31 * result + messageTypeId
    result = 31 * result + bodyBytes
    return result
  }

  init {
    require(gameData.bytes.isNotEmpty()) { "gameData is empty" }
    require(gameData.size in 0..0xFFFF) { "gameData size out of range: ${gameData.size}" }
  }

  companion object {
    const val ID: Byte = 0x12

    // TODO(nue): Get rid of this.
    @Throws(Exception::class)
    fun main() {
      val data = ByteArray(9)
      val st = System.currentTimeMillis()
      val msg = GameData(0, VariableSizeByteArray(data))
      val byteBuffer = ByteBuffer.allocateDirect(4096)
      for (i in 0..0xfffe) {
        msg.writeTo(byteBuffer)
        byteBuffer.clear()
      }
      println("et=" + (System.currentTimeMillis() - st))
    }

    /** Same as the constructor, but it makes a deep copy of the array. */
    @Throws(MessageFormatException::class)
    fun createAndMakeDeepCopy(messageNumber: Int, gameData: VariableSizeByteArray): GameData {
      return GameData(messageNumber, gameData.clone())
    }
  }

  object GameDataSerializer : MessageSerializer<GameData> {
    private val logger = FluentLogger.forEnclosingClass()
    override val messageTypeId: Byte = ID

    override fun read(buffer: ByteBuf, messageNumber: Int): Result<GameData> {
      if (buffer.readableBytes() < 4) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.readByte() // This is always 0x00.
      val dataSize = buffer.getUnsignedShort()
      if (dataSize <= 0 || dataSize > buffer.readableBytes()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = ByteArray(dataSize)
      buffer.readBytes(gameData) // THIS IS PROBABLY SAFE
      return Result.success(GameData(messageNumber, VariableSizeByteArray(gameData)))
    }

    override fun read(buffer: ByteBuffer, messageNumber: Int): Result<GameData> {
      if (buffer.remaining() < 4) {
        return parseFailure("Failed byte count validation!")
      }
      buffer.get() // This is always 0x00.
      val dataSize = buffer.getUnsignedShort()
      if (dataSize <= 0 || dataSize > buffer.remaining()) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = VariableSizeByteArray.pool.claim()
      gameData.size = dataSize
      buffer.get(gameData)
      return Result.success(GameData(messageNumber, gameData))
    }

    override fun read(packet: Source, messageNumber: Int): Result<GameData> {
      if (packet.remaining < 4) {
        return parseFailure("Failed byte count validation!")
      }
      packet.readByte() // This is always 0x00.
      val dataSize = packet.readUnsignedShortLittleEndian()
      if (dataSize <= 0 || dataSize > packet.remaining) {
        return parseFailure("Invalid Game Data format: dataSize = $dataSize")
      }
      val gameData = ByteArray(dataSize)
      packet.readAvailable(gameData) // TODO(nue): This might not work?
      return Result.success(GameData(messageNumber, VariableSizeByteArray(gameData)))
    }

    override fun write(buffer: ByteBuf, message: GameData) {
      buffer.writeByte(0x00)
      buffer.putUnsignedShort(message.gameData.size)
      buffer.writeBytes(message.gameData.toByteArray())
    }

    override fun write(buffer: ByteBuffer, message: GameData) {
      buffer.put(0x00.toByte())
      buffer.putUnsignedShort(message.gameData.size)
      buffer.put(message.gameData)
    }
  }
}
